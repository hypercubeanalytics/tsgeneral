# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_ingest.ipynb.

# %% auto 0
__all__ = ['read', 'create_schema']

# %% ../nbs/00_ingest.ipynb 3
import re
import pandas as pd        
import numpy as np 
import traceback
import datetime
from cerberus import Validator
from urllib.error import URLError

# %% ../nbs/00_ingest.ipynb 4
def read(file_type: str, file_path: str) -> tuple:
    """
    This function read  helps  to read any of a csv,excel and parquet file,
    and returns a pandas dataframe.

    Parameters
    ----------
    file_type: file type must be one of csv,excel or parquet format.
    file: file path.

    Returns
    -------
        if   errors - function returns tuple with boolean value  "False" and dictionary with errors 
        if no errors - function returns tuple with boolean value  "True" and  dataframe

    """

    report_dict = {}
    errors = {}
    emptydf = pd.DataFrame()
    error_flag = False

    if file_type not in ['csv', 'excel', 'parquet']:
        errors["error"] = "unsupported file format please pass one of csv,excel or parquet types"
        return (False, errors, emptydf)

    # first set of checks on file missing, corrupted, etc.
    try:
        if file_type == 'csv':
            df = pd.read_csv(file_path)
        if file_type == 'excel':
            df = pd.read_excel(file_path)
        if file_type == 'parquet':
            df = pd.read_parquet(file_path)

    except FileNotFoundError as e:
        errors["error"] = (
            "File not found please check file path", traceback.format_exc())
        error_flag = True
    except URLError as e1:
        errors["error"] = ('URL not found,invalid URL', traceback.format_exc())
        error_flag = True
    except UnicodeDecodeError as e2:
        errors["error"] = (
            "corrupted data or wrong file format", traceback.format_exc())
        error_flag = True
    except ValueError as e3:
        errors["error"] = (
            "corrupted data or wrong file format", traceback.format_exc())
        error_flag = True
    except:
        errors["error"] = ("UnKnow error occured ", traceback.format_exc())
        error_flag = True

    if error_flag:
        return (False, errors)
    return (True, df)

# %% ../nbs/00_ingest.ipynb 15
def create_schema(col_dict: dict) -> tuple:
    """
      This function create_schema  helps  to  create cerberus schema froma given dictionary and 
      retuns schema for cerberus validation.

      Parameters
      ----------
      col_dict: dictionary with column name  as keys  and  dtypes  as  values, 
                e.g., d={"colmn_name":float,"colmn_name":int} ,for date {"colmn_name":("date","%Y-%m-%d")}.
                Note, date  is an special case need to pass a tuple with key "date" and format.
                supported dtypes : int ,float,str,date

      Returns
      -------
       if   errors - function returns tuple with boolean value  "False" and dictionary with errors. 
       if no errors - function returns tuple with boolean value  "True" and schema in dict form.

    """
    errors = {}
    emptydf = pd.DataFrame()

    # prepare schema
    schema = {}
    for k, v in col_dict.items():
        if v is int:
            schema[k] = {"type": "integer", 'coerce': int}
        elif v is float:
            schema[k] = {"type": "float", 'coerce': float}
        elif v is str:
            schema[k] = {"type": "string", 'coerce': str}
        elif type(v) is tuple:
            if v[0] in ["date", "datetime"]:
                dt = str(v[1])
                schema[k] = {"type": "datetime",
                             'coerce': lambda d: datetime.datetime.strptime(d, dt)}
            else:
                errors["error"] = (
                    f"datatype error at  {k}", f"Unknow data type ,  {v[0]} for column {k}")
                return (False, errors, emptydf)
        else:
            errors["error"] = (
                f"datatype error at {k}", f"Unknow data type ,  {v} for column {k}")
            return (False, errors)
    return (True, schema)
